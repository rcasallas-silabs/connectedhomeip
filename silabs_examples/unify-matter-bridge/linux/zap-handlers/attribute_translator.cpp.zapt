/******************************************************************************
 * # License
 * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

#define CHIP_USE_ENUM_CLASS_FOR_IM_ENUM

#include <nlohmann/json.hpp>
#include <sstream>
#include <regex>
#include <type_traits>
#include "matter.h"

#include <attribute_state_cache.hpp>
#include "attribute_translator.hpp"
#include "matter_device_translator.hpp"
#include "cluster_emulator.hpp"

#include "uic_mqtt.h"
#include "sl_log.h"
#include "app-common/zap-generated/attributes/Accessors.h"
#define LOG_TAG "attribute_translator"

using namespace chip;
using namespace chip::app;
using namespace chip::app::Clusters;
using namespace unify::matter_bridge;

#include "chip_types_to_json.hpp"
#include "chip_types_from_json.hpp"
#include "unify_accessors.hpp"

{{#zcl_clusters}}
{{#if (unifySupportedCluster code)}}
CHIP_ERROR
{{asUpperCamelCase label}}AttributeAccess::Read(const ConcreteReadAttributePath &aPath,
                           AttributeValueEncoder &aEncoder)
{
  namespace MN = chip::app::Clusters::{{asUpperCamelCase label}}::Attributes;
  namespace UN = unify::matter_bridge::{{asUpperCamelCase label}}::Attributes;
  if (aPath.mClusterId != Clusters::{{asUpperCamelCase label}}::Id) {
    return CHIP_ERROR_INVALID_ARGUMENT;
  }
  // Do not handle Read for non-unify endpoints
  auto unify_node = m_node_state_monitor.bridged_endpoint(aPath.mEndpointId);

  if (!unify_node) {
    return CHIP_NO_ERROR;
  }


  ConcreteAttributePath atr_path = ConcreteAttributePath(aPath.mEndpointId,
                                                        aPath.mClusterId,
                                                        aPath.mAttributeId);

  
  if( m_node_state_monitor.emulator().is_attribute_emulated(aPath) ) {
    return m_node_state_monitor.emulator().read_attribute(aPath,aEncoder);
  }
  
  try {
    switch (aPath.mAttributeId) {
    {{#zcl_attributes_server}}
    {{#if_is_struct type}}
    {{else if (canHaveSimpleAccessors this)}}
    case MN::{{asUpperCamelCase label}}::Id: {     // type is {{type}}
      MN::{{asUpperCamelCase label}}::TypeInfo::Type value;
      UN::{{asUpperCamelCase label}}::Get(atr_path, value);
      return aEncoder.Encode(value);
    }
    {{/if_is_struct}}
    {{/zcl_attributes_server}}
    }
  } catch (const std::out_of_range &e) {
    sl_log_info(
      LOG_TAG,
      "The request attribute Path for endpoint [%i] is not found in the attribute state "
      "container: %s\n", atr_path.mEndpointId, e.what());
      return CHIP_ERROR_NO_MESSAGE_HANDLER;
  }
  return CHIP_NO_ERROR;
}

CHIP_ERROR {{asUpperCamelCase label}}AttributeAccess::Write(const ConcreteDataAttributePath &aPath,
                                       AttributeValueDecoder &aDecoder)
{
  using namespace chip::app::Clusters::{{asUpperCamelCase label}};

  if (aPath.mClusterId != Clusters::{{asUpperCamelCase label}}::Id) {
    return CHIP_ERROR_INVALID_ARGUMENT;
  }
  auto unify_node = m_node_state_monitor.bridged_endpoint(aPath.mEndpointId);

  if (!unify_node) {
    return CHIP_ERROR_NO_MESSAGE_HANDLER;
  }

  std::string attribute_name;
  nlohmann::json jsn;

  if( m_node_state_monitor.emulator().is_attribute_emulated(aPath) ) {
    return m_node_state_monitor.emulator().write_attribute(aPath,aDecoder);
  }

  switch (aPath.mAttributeId) {
  {{#zcl_attributes_server}}
  {{#if isWritable }}
  {{#if (unifySupportedClusterAttribute parent.code code)}}
  case Attributes::{{asUpperCamelCase label}}::Id: {

      Attributes::{{asUpperCamelCase label}}::TypeInfo::DecodableType value;
      aDecoder.Decode(value);
      jsn["value"]   = to_json(value);
      attribute_name = "{{unifyClusterAttributeName parent.code code}}";
      break;
  }
  {{/if}}
  {{else}}
  // {{label}} is not supported by UCL
  {{/if}}
  {{/zcl_attributes_server}}
  }

  if (!attribute_name.empty()) {
    std::string payload_str;
    std::string topic = "ucl/by-unid/" + unify_node->unify_unid + "/ep"
                  + std::to_string(unify_node->unify_endpoint)
                  + "/{{unifyClusterName code}}/Attributes/" + attribute_name + "/Desired";
    payload_str = jsn.dump();
    m_unify_mqtt.Publish(topic,
                        payload_str,
                        true);
    return CHIP_NO_ERROR;
  }

  return CHIP_ERROR_NO_MESSAGE_HANDLER;
}

void {{asUpperCamelCase label}}AttributeAccess::reported_updated(const bridged_endpoint *ep,
                                            const std::string &cluster,
                                            const std::string &attribute,
                                            const nlohmann::json &unify_value)
{
  namespace MN = chip::app::Clusters::{{asUpperCamelCase label}}::Attributes;
  namespace UN = unify::matter_bridge::{{asUpperCamelCase label}}::Attributes;

  auto cluster_id = m_dev_translator.get_cluster_id(cluster);

  if (!cluster_id.has_value() || (cluster_id.value() != Clusters::{{asUpperCamelCase label}}::Id)) {
    return;
  }

  // get attribute id
  auto attribute_id
    = m_dev_translator.get_attribute_id(cluster, attribute);

  if (!attribute_id.has_value()) {
    return;
  }

  chip::EndpointId node_matter_endpoint = ep->matter_endpoint;
  ConcreteAttributePath attrpath = ConcreteAttributePath(node_matter_endpoint,
                                                         Clusters::{{asUpperCamelCase label}}::Id,
                                                         attribute_id.value());
  switch (attribute_id.value()) {
    {{#zcl_attributes_server}}
    {{#if (unifySupportedClusterAttribute parent.code code)}}
    {{#if_is_struct type}}
    {{else if (canHaveSimpleAccessors this)}}
    // type is {{type}}
    case MN::{{asUpperCamelCase label}}::Id: {
      using T = MN::{{asUpperCamelCase label}}::TypeInfo::Type;
      std::optional<T> value = from_json<T>(unify_value);
      
      if( value.has_value()) {
        sl_log_debug(LOG_TAG,"{{asUpperCamelCase label}} attribute value is %s",unify_value.dump().c_str());
        UN::{{asUpperCamelCase label}}::Set(attrpath, value.value());
        MatterReportingAttributeChangeCallback(
          node_matter_endpoint,
          Clusters::{{asUpperCamelCase parent.label}}::Id,
          MN::{{asUpperCamelCase label}}::Id);
      }
      break;
    }
    {{/if_is_struct}}
    {{/if}}
    {{/zcl_attributes_server}}
  }
}

{{/if}}
{{/zcl_clusters}}
